// Generated by CoffeeScript 1.3.3
var async, cached_files, collectDependencies, compile, extensions, fs, options, parseFile, path, resolveDependencyChain, resolvePath, root, watchFile, watchFileFallback, watchFiles;

fs = require('fs');

path = require('path');

async = require('async');

cached_files = {};

root = null;

options = null;

parseFile = function(full_path, cb) {
  var file;
  file = {
    path: full_path,
    compiled_js: null,
    mtime: null,
    deps: []
  };
  return fs.stat(full_path, function(err, stat) {
    if (err) {
      cb(err);
      return;
    }
    file.mtime = +stat.mtime;
    return fs.readFile(full_path, 'utf8', function(err, source) {
      var import_string, parser, re, result, timestamp;
      if (err) {
        cb(err);
        return;
      }
      parser = extensions[path.extname(full_path)];
      try {
        file.compiled_js = parser.compile(source);
      } catch (err) {
        cb("" + full_path + "\n" + err, file);
        return;
      }
      if (options.watch) {
        timestamp = (new Date()).toLocaleTimeString();
        console.info("" + timestamp + " - compiled " + file.path);
      }
      re = parser.import_re;
      re.lastIndex = 0;
      while (result = re.exec(source)) {
        import_string = result[1].slice(1, -1);
        if (import_string[0] !== '/') {
          import_string = path.join(path.dirname(full_path), import_string);
        }
        file.deps.push(import_string);
      }
      return cb(null, file);
    });
  });
};

resolvePath = function(import_string, doneResolvingPath) {
  var resolveWithExt;
  resolveWithExt = function(ext, cb) {
    return fs.realpath(path.resolve(import_string + ext), function(err, real_path) {
      if (err) {
        cb(null, null);
        return;
      }
      return fs.stat(real_path, function(err, stat) {
        if (err || stat.isDirectory()) {
          return cb(null, null);
        } else {
          return cb(null, real_path);
        }
      });
    });
  };
  return async.map([""].concat(Object.keys(extensions)), resolveWithExt, function(err, results) {
    return async.filter(results, (function(item, cb) {
      return cb(item != null);
    }), function(results) {
      if (results.length === 1) {
        doneResolvingPath(null, results[0]);
      } else if (results.length === 0) {
        doneResolvingPath("unable to resolve import: " + import_string);
      } else if (results.length > 1) {
        doneResolvingPath("ambiguous import: " + import_string);
      }
    });
  });
};

resolveDependencyChain = function(root, doneResolvingDependencyChain) {
  var deps, processNode, seen;
  deps = [];
  seen = {};
  processNode = function(node, doneProcessingNode) {
    return async.map(node.deps, resolvePath, function(err, resolved_deps) {
      var dep, dep_path, funcs, _i, _len;
      if (err) {
        doneResolvingDependencyChain(err);
        return;
      }
      funcs = [];
      for (_i = 0, _len = resolved_deps.length; _i < _len; _i++) {
        dep_path = resolved_deps[_i];
        dep = cached_files[dep_path];
        if (seen[dep.path] != null) {
          continue;
        }
        seen[dep.path] = true;
        funcs.push(async.apply(processNode, dep));
      }
      return async.parallel(funcs, function(err, results) {
        if (err) {
          doneResolvingDependencyChain(err);
          return;
        }
        deps.push(node);
        return doneProcessingNode();
      });
    });
  };
  return processNode(root, function() {
    return doneResolvingDependencyChain(null, deps);
  });
};

collectDependencies = function(import_string, doneCollectingDependencies) {
  return resolvePath(import_string, function(err, canonical_path) {
    var cached_file, callNext, parseAndHandleErr;
    if (err) {
      doneCollectingDependencies(err);
      return;
    }
    parseAndHandleErr = function(cb) {
      return parseFile(canonical_path, function(err, file) {
        if (file) {
          cached_files[file.path] = file;
          if (root == null) {
            root = file;
          }
        }
        if (err) {
          doneCollectingDependencies(err);
        } else {
          cb(file);
        }
      });
    };
    callNext = function(file) {
      return async.map(file.deps, collectDependencies, doneCollectingDependencies);
    };
    if ((cached_file = cached_files[canonical_path]) != null) {
      return fs.stat(canonical_path, function(err, stat) {
        if (cached_file.mtime === +stat.mtime) {
          if (root == null) {
            root = cached_file;
          }
          return callNext(cached_file);
        } else {
          return parseAndHandleErr(callNext);
        }
      });
    } else {
      return parseAndHandleErr(callNext);
    }
  });
};

watchFileFallback = function(filename, options, cb) {
  options.interval = 701;
  fs.watchFile(filename, options, function(curr, prev) {
    if (curr.mtime !== prev.mtime) {
      return cb("change", filename);
    }
  });
  return {
    close: function() {
      return fs.unwatchFile(filename);
    }
  };
};

watchFile = fs.watch || watchFileFallback;

watchFiles = function(files, cb) {
  var doCallback, file, watcher, watchers, _i, _len, _results;
  watchers = [];
  doCallback = function(event) {
    var watcher, _i, _len;
    if (event === "change") {
      for (_i = 0, _len = watchers.length; _i < _len; _i++) {
        watcher = watchers[_i];
        watcher.close();
      }
      return cb();
    }
  };
  _results = [];
  for (_i = 0, _len = files.length; _i < _len; _i++) {
    file = files[_i];
    try {
      watcher = fs.watch(file, doCallback);
    } catch (err) {
      watcher = watchFileFallback(file, doCallback);
    }
    _results.push(watchers.push(watcher));
  }
  return _results;
};

compile = function(_options, cb) {
  options = _options;
  root = null;
  return collectDependencies(options.mainfile, function(collect_err) {
    if (collect_err && !(root != null)) {
      cb(collect_err);
      return;
    }
    return resolveDependencyChain(root, function(err, dependency_chain) {
      var dep, output;
      if (_options.watch) {
        watchFiles((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = dependency_chain.length; _i < _len; _i++) {
            dep = dependency_chain[_i];
            _results.push(dep.path);
          }
          return _results;
        })(), function() {
          return compile(_options, cb);
        });
      }
      if (err) {
        cb(err);
      } else if (collect_err) {
        cb(collect_err);
      } else {
        output = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = dependency_chain.length; _i < _len; _i++) {
            dep = dependency_chain[_i];
            _results.push(dep.compiled_js);
          }
          return _results;
        })()).join("\n");
        cb(null, output);
      }
    });
  });
};

extensions = {
  '.coffee': {
    compile: function(code) {
      return require('coffee-script').compile(code, {
        bare: options.bare
      });
    },
    import_re: /^#import (".+")$/gm
  },
  '.js': {
    compile: function(code) {
      if (options.bare) {
        return code;
      } else {
        return "(function(){\n" + code + "}).call(this);";
      }
    },
    import_re: /^\/\/import (".+");?$/gm
  },
  '.co': {
    compile: function(code) {
      return require('coco').compile(code, {
        bare: options.bare
      });
    },
    import_re: /^#import (".+")$/gm
  },
  '.ls': {
    compile: function(code) {
      return require('LiveScript').compile(code, {
        bare: options.bare
      });
    },
    import_re: /^#import (".+")$/gm
  }
};

module.exports = {
  compile: compile,
  extensions: extensions
};
