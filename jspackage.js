// Generated by CoffeeScript 1.3.3
var async, cached_files, collectDependencies, compile, extensions, fs, libs, parseFile, path, resolveDepend, resolveDependencyChain, root, watchFile, watchFileFallback, watchFiles, watching,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

async = require('async');

cached_files = {};

watching = null;

libs = null;

root = null;

parseFile = function(resolved_dep, cb) {
  var file;
  file = {
    path: resolved_dep.path,
    compiled_js: null,
    mtime: null,
    deps: [],
    cwd: path.dirname(resolved_dep.path)
  };
  return fs.stat(resolved_dep.path, function(err, stat) {
    if (err) {
      cb(err);
      return;
    }
    file.mtime = +stat.mtime;
    return fs.readFile(resolved_dep.path, 'utf8', function(err, source) {
      var parser, re, result, timestamp;
      if (err) {
        cb(err);
        return;
      }
      parser = extensions[path.extname(resolved_dep.path)];
      try {
        file.compiled_js = parser.compile(source, resolved_dep.options);
      } catch (err) {
        cb("" + resolved_dep.path + "\n" + err, file);
        return;
      }
      if (watching) {
        timestamp = (new Date()).toLocaleTimeString();
        console.info("" + timestamp + " - compiled " + file.path);
      }
      re = parser.depend_re;
      re.lastIndex = 0;
      while (result = re.exec(source)) {
        file.deps.push({
          depend: result[1],
          options: {
            bare: result[2] != null
          },
          cwd: file.cwd,
          seen: resolved_dep.seen.concat(file.path)
        });
      }
      return cb(null, file);
    });
  });
};

resolveDepend = function(dep, doneResolvingDepend) {
  var lib_index, tryNextLib, try_exts;
  try_exts = Object.keys(extensions);
  lib_index = 0;
  tryNextLib = function() {
    var resolveWithExt, try_lib;
    if ((try_lib = libs[lib_index++]) != null) {
      resolveWithExt = function(ext, cb) {
        var resolved_path;
        resolved_path = path.resolve(dep.cwd, try_lib, dep.depend + ext);
        return fs.realpath(resolved_path, function(err, real_path) {
          if (err) {
            cb(null, null);
            return;
          }
          return fs.stat(real_path, function(err, stat) {
            if (err || stat.isDirectory()) {
              return cb(null, null);
            } else {
              return cb(null, real_path);
            }
          });
        });
      };
      return async.map(try_exts, resolveWithExt, function(err, results) {
        return async.filter(results, (function(item, cb) {
          return cb(item != null);
        }), function(results) {
          if (results.length === 1) {
            doneResolvingDepend(null, {
              path: results[0],
              options: dep.options,
              seen: dep.seen
            });
          } else if (results.length === 0) {
            tryNextLib();
          } else if (results.length > 1) {
            doneResolvingDepend("ambiguous dependency: " + dep.depend);
          }
        });
      });
    } else {
      return doneResolvingDepend("unable to resolve dependency: " + dep.depend);
    }
  };
  return tryNextLib();
};

resolveDependencyChain = function(root, doneResolvingDependencyChain) {
  var files, processNode, seen;
  files = [];
  seen = {};
  processNode = function(node, doneProcessingNode) {
    return async.map(node.deps, resolveDepend, function(err, resolved_deps) {
      var dep, file, funcs, _i, _len;
      if (err) {
        doneProcessingNode(err);
        return;
      }
      funcs = [];
      for (_i = 0, _len = resolved_deps.length; _i < _len; _i++) {
        dep = resolved_deps[_i];
        file = cached_files[dep.path];
        if (seen[file.path] != null) {
          continue;
        }
        seen[file.path] = true;
        funcs.push(async.apply(processNode, file));
      }
      return async.parallel(funcs, function(err, results) {
        files.push(node);
        if (err) {
          doneProcessingNode(err);
          return;
        }
        return doneProcessingNode(null);
      });
    });
  };
  return processNode(root, function(err) {
    return doneResolvingDependencyChain(err, files);
  });
};

collectDependencies = function(dep, doneCollectingDependencies) {
  return resolveDepend(dep, function(err, resolved_dep) {
    var cached_file, callNext, dep_chain, parseAndHandleErr, _ref;
    if (err) {
      doneCollectingDependencies(err);
      return;
    }
    if (_ref = resolved_dep.path, __indexOf.call(dep.seen, _ref) >= 0) {
      dep_chain = dep.seen.concat(resolved_dep.path).join(" depends on\n");
      doneCollectingDependencies("circular dependency:\n" + dep_chain);
      return;
    }
    parseAndHandleErr = function(cb) {
      return parseFile(resolved_dep, function(err, file) {
        if (file) {
          cached_files[file.path] = file;
          if (root == null) {
            root = file;
          }
        }
        if (err) {
          doneCollectingDependencies(err);
        } else {
          cb(file);
        }
      });
    };
    callNext = function(file) {
      return async.map(file.deps, collectDependencies, doneCollectingDependencies);
    };
    if ((cached_file = cached_files[resolved_dep.path]) != null) {
      return fs.stat(resolved_dep.path, function(err, stat) {
        if (cached_file.mtime === +stat.mtime) {
          if (root == null) {
            root = cached_file;
          }
          return callNext(cached_file);
        } else {
          return parseAndHandleErr(callNext);
        }
      });
    } else {
      return parseAndHandleErr(callNext);
    }
  });
};

watchFileFallback = function(filename, options, cb) {
  options.interval = 701;
  fs.watchFile(filename, options, function(curr, prev) {
    if (curr.mtime !== prev.mtime) {
      return cb("change", filename);
    }
  });
  return {
    close: function() {
      return fs.unwatchFile(filename);
    }
  };
};

watchFile = fs.watch || watchFileFallback;

watchFiles = function(files, cb) {
  var doCallback, file, watcher, watchers, _i, _len, _results;
  watchers = [];
  doCallback = function(event) {
    var watcher, _i, _len;
    if (event === "change") {
      for (_i = 0, _len = watchers.length; _i < _len; _i++) {
        watcher = watchers[_i];
        watcher.close();
      }
      return cb();
    }
  };
  _results = [];
  for (_i = 0, _len = files.length; _i < _len; _i++) {
    file = files[_i];
    try {
      watcher = fs.watch(file, doCallback);
    } catch (err) {
      watcher = watchFileFallback(file, doCallback);
    }
    _results.push(watchers.push(watcher));
  }
  return _results;
};

compile = function(options, cb) {
  var dep, lib, _ref;
  watching = options.watch;
  libs = (_ref = options.libs) != null ? _ref : [];
  libs = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = libs.length; _i < _len; _i++) {
      lib = libs[_i];
      _results.push(path.resolve(lib));
    }
    return _results;
  })();
  libs.unshift(".");
  root = null;
  dep = {
    depend: options.mainfile,
    options: {
      bare: options.bare
    },
    cwd: process.cwd(),
    seen: []
  };
  return collectDependencies(dep, function(collect_err) {
    if (collect_err && !(root != null)) {
      cb(collect_err);
      return;
    }
    return resolveDependencyChain(root, function(err, dependency_chain) {
      var output;
      if (watching) {
        watchFiles((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = dependency_chain.length; _i < _len; _i++) {
            dep = dependency_chain[_i];
            _results.push(dep.path);
          }
          return _results;
        })(), function() {
          return compile(options, cb);
        });
      }
      if (err) {
        cb(err);
      } else if (collect_err) {
        cb(collect_err);
      } else {
        output = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = dependency_chain.length; _i < _len; _i++) {
            dep = dependency_chain[_i];
            _results.push(dep.compiled_js);
          }
          return _results;
        })()).join("\n");
        cb(null, output);
      }
    });
  });
};

extensions = {
  '.coffee': {
    compile: function(code, options) {
      return require('coffee-script').compile(code, {
        bare: options.bare
      });
    },
    depend_re: /^#depend "(.+)"( bare)?$/gm
  },
  '.js': {
    compile: function(code, options) {
      if (options.bare) {
        return code;
      } else {
        return "(function(){\n" + code + "}).call(this);";
      }
    },
    depend_re: /^\/\/depend "(.+)"( bare)?;?$/gm
  },
  '.co': {
    compile: function(code, options) {
      return require('coco').compile(code, {
        bare: options.bare
      });
    },
    depend_re: /^#depend "(.+)"( bare)?$/gm
  },
  '.ls': {
    compile: function(code, options) {
      return require('LiveScript').compile(code, {
        bare: options.bare
      });
    },
    depend_re: /^#depend "(.+)"( bare)?$/gm
  }
};

module.exports = {
  compile: compile,
  extensions: extensions
};
